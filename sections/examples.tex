% !TEX root=../main.tex


\section{Examples}
\label{sec:examples}

This section will briefly introduce the task-oriented programming language \TOPHAT,
accompanied by two examples to illustrate how the language works and what kind of properties we would like to prove.

\subsection{\TOPHAT}

\TOPHAT is a task-oriented programming language.
Its aim is to model real world collaboration.

Programs in \TOPHAT are called tasks.
The smallest elements of a task is called an editor.

Editors are the basic method for communicating with the outside world.
There are three different Editors.
\begin{description}
  \item[$\Edit v$] Valued editor.\\
    This editor holds a value $v$ of a certain type.
    A new value of that type can be given as input.
  \item[$\Enter \tau$] Unvalued editor.\\
    This editor holds no value, and can receive a value of type $\tau$.
    It will then turn into a valued editor.
  \item[$\Update l$] Shared editor.\\
    This editor refers to a shared location $l$.
    Its observable value is the value stored at that location.
    It can receive a new value, this value will then be stored at location $l$.
\end{description}

Editors can be combined into tasks using combinators.
These combinators describe the way people collaborate.
The following combinators are available in \TOPHAT.

\begin{description}
  \item[$t \Then e$] Step.\\
  Users can work on task $t$.
  As soon as $t$ yields a value, that value is passed on to the right hand side, with which it continues.
  \item[$t \Next e$] User Step.\\
  Users can work on task $t$.
  When they are done, and $t$ yields a value, the user can send a continue event to the combinator.
  The value of $t$ is then passed on to the right hand side, with which it continues.
  \item[$t_1 \And t_1$] Composition.\\
  Users can work on tasks $t_1$ and $t_2$ at the same time.
  \item[$t_1 \Or t_2$] Choice.\\
  The system chooses between $t_1$ or $t_2$. If either of those returns a value, the system chooses that task.
  \item[$e_1 \Xor e_1$] User choice.\\
  A user has to make a choice between either the left or the right hand side.
  The user continues to work on the chosen task.
\end{description}

In addition to editors and combinators, \TOPHAT also contains a fail task $\Fail$.
This task is used by programmers to indicate that a task is not reachable or viable.
For example, when the right hand side of a step combinator is $\Fail$, the step will not proceed onto that task.

This language of tasks and combinators is embedded in the simply typed lambda calculus, augmented with references, pairs, if-then-else, booleans, integers and string, and unary and binary operations on these constants.
The full syntax of this host language is listed in Section~\ref{expressions}.

The references present in the host language allow tasks to communicate with each other,
sharing information that is globally available.

Finally, several observations can be made over tasks.
Using the value function $\Value$, the current value of a task can be determined.
The value function is a partial function, since not all tasks have a value.
For example, $\Enter \tau$ holds no value.
We can also observe wether or not a task is failing, by means of the failing function $\Failing$.
The step combinator makes use of both functions in order to determine if it can step.
First, it uses $\Value$ to see if the left hand side produces a value.
If that is the case, it uses the $\Failing$ function to see if it is safe to step to the right hand side using that value.
The complete definition of the value and failing function are listed in Section~\ref{subsec:observations}.


\subsection{Tax subsidy request}

\citet{conf/sfp/StutterheimAP17} worked with the Dutch tax office to develop a demonstrator for a fictional but realistic law about solar panel subsidies.
In this section we study a simplified version of this, translated to \TOPHAT, to illustrate how symbolic TopHat can be used to prove that the program implements the law.

This example proves that a citizen will get subsidy only under the following conditions.
\begin{itemize}
\item The company has confirmed that they installed solar panels for the citizen.
\item The tax officer has approved the request.
\item The tax officer can only approve the request if the company has confirmed, and the request is filed within one year of the invoice date.
\item The amount of the granted subsidy is maximal 600 EUR.
\end{itemize}

\begin{figure}
\lstset{emph={invoiceDate,today,confirmed,invoiceAmount,decision}}
\begin{TASK}
  let provideCitizenInformation = enter Date in
  let provideDocuments = enter Amount <&> enter Date in
  let companyConfirm = edit True <?> edit False in
  let officerApprove = \ invoiceDate. \ today. \ confirmed.
    edit False <?> if (today - invoiceDate < 365 /\ confirmed)
      then edit True else fail in
  provideCitizenInformation >>= \ today.
  provideDocuments <&> companyConfirm >>= \ <<<<invoiceAmount,
    invoiceDate>>, confirmed>>.
  officerApprove invoiceDate today confirmed >>= \ decision.
  let subsidyAmount = if decision
    then min 600 (invoiceAmount / 10) else 0 in
  edit <<subsidyAmount, decision, confirmed, invoiceAmount,
    invoiceDate, today>>
\end{TASK}
\caption{Subsidy request and approval workflow at the Dutch tax office.}
\label{fig:thetaxman}
\end{figure}

\Cref{fig:thetaxman} shows the program.
It works as follows.
First, the citizen has to enter their home address and today's date.
Then, in parallel the citizen has to provide the invoice documents of the installed solar panels, while the solar panel company has to confirm that they have actually installed solar panels at the citizen's address.
Once the invoice and the confirmation are there, the tax officer has to approve the request.
The officer can always decline the request, but they can only approve it if the company has confirmed and the application date is within one year after the invoice date.
The result of the program is the amount of the subsidy, together with all information needed to prove the required properties.
\fixme{Write property}



\subsection{Flight booking}

In this section we develop a small flight booking system.
The purpose of this example is to demonstrate how Symbolic TopHat handles references and lists.
We prove that when the program terminates, every passenger has exactly one seat, and that no two passengers have the same seat.
This program is a simplified version of what we presented in earlier work \cite{Steenvoorden2019}.

\begin{figure}
\begin{TASK}
  let maxSeats = 50 in
  let bookedSeats = ref [] in
  let bookSeat = enter Int >>= \ x .
    if x `elem` !bookedSeats \/ x > maxSeats
      then fail else bookedSeats := x :: !bookedSeats in
  bookSeat <&> bookSeat <&> bookSeat >>= \ _ .
  edit (!bookedSeats)
\end{TASK}
\caption{Flight booking}
\label{fig:flight-booking}
\end{figure}

The main program, shown in \cref{fig:flight-booking}, consists of three parallel seat booking tasks.
There is a shared list that stores all seats that have been booked so far.
In order to book a seat, a passenger has to enter a seat number.
A guard makes sure that only free seats can be booked.
