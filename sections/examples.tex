% !TEX root=../main.tex

\section{Examples}
\label{sec:examples}

In this section we study three examples to illustrate how the language works and what kind of properties we would like to prove.



\subsection{Absolute value}

\begin{example}
\label{exm:abs}
Consider the following example program.
\begin{TASK}
  enter Int >>= \ x. if x > 0 then edit x else fail
\end{TASK}

It asks the user to input a value of type $\Int$.
This value is then passed on to the right hand side.
If the value is larger than zero, as determined by the condition $x>0$,
an editor containing the entered value is returned.
Otherwise, the user is asked to input a different value, until the condition holds.
\end{example}

Imagine we would like to prove that no matter what value is given as input,
the only possible outcome is a value larger than zero.

The symbolic execution enters a symbol $s$ as input into the editor on the left.
The execution then arrives at a branching point.
In order to take the then-branch, the condition $s > 0$ needs to hold.
This branch will then result in $\Edit s$.
We can now observe a task value, which is $s$.
We record this endpoint together with its path condition $s > 0$.
The else branch applies if the condition does not hold.
But this leads to a failing task.
Therefore, the step is not taken and the programs stays the same.
Next, the user is still asked to enter an integer value.

The execution results in a list of all possible program results,
guarded by certain constraints on the symbolic input.
If these possible outcomes agree with the stated property,
it is guaranteed that his will hold for all paths.

So, from the symbolic execution we obtain that the only outcome of this program is $s > 0$.
From that outcome, we can conclude that no matter what input is given, the only result value possible has to be larger than zero.



\subsection{Tax subsidy request}

\citet{conf/sfp/StutterheimAP17} worked with the Dutch tax office to develop a demonstrator for a fictional but realistic law about solar panel subsidies.
In this section we study a simplified version of this, translated to \TOPHAT, to illustrate how symbolic TopHat can be used to prove that the program implements the law.

This example proves that a citizen will get subsidy only under the following conditions.
\begin{itemize}
\item The roofing company has confirmed that they installed solar panels for the citizen.
\item The tax officer has approved the request.
\item The tax officer can only approve the request if the roofing company has confirmed, and the request is filed within one year of the invoice date.
\item The amount of the granted subsidy is maximal 600 EUR.
\end{itemize}

\lstset{emph={invoiceDate,today,confirmed,invoiceAmount,decision}}
\begin{TASK}[float=t
            ,numbers=right
            ,caption=Subsidy request and approval workflow at the Dutch tax office.
            ,label=fig:thetaxman
            ]
  let provideCitizenInformation = enter Date in
  let provideDocuments = enter Amount <&> enter Date in
  let companyConfirm = edit True <?> edit False in
  let officerApprove = \ invoiceDate. \ today. \ confirmed.
    edit False <?> if (today - invoiceDate < 365 /\ confirmed) |\label{fig:taxman-officer-approve-def}|
      then edit True else fail in
  provideCitizenInformation >>= \ today.|\label{fig:taxman-citizen-info}|
  provideDocuments <&> companyConfirm >>= |\label{fig:taxman-documents-and-company-confirm}|
    \ <<<<invoiceAmount, invoiceDate>>, confirmed>>.
  officerApprove invoiceDate today confirmed >>= \ decision.|\label{fig:taxman-officer-approve}|
  let subsidyAmount = if decision
    then min 600 (invoiceAmount / 10) else 0 in
  edit <<subsidyAmount, decision, confirmed, invoiceAmount,|\label{fig:taxman-result}|
    invoiceDate, today>>
\end{TASK}

\fixme{Spacing...}

\Cref{fig:thetaxman} shows the program.
To enhance readability of the example,
we omit type annotations and make use of pattern matching on tuples.
The program works as follows.
First, the citizen has to enter their personal information (\cref{fig:taxman-citizen-info}).
In the original demonstrator this included the citizen service number, name, and home address.
The current date was obtained from the system.
For the example here we simplified it so that the citizen only has to enter the current date, because the other information were used only for display.
For simplicity, a date is specified using an integer representing the number of days since 1 January 2000.

In the next step (\cref{fig:taxman-documents-and-company-confirm}), in parallel the citizen has to provide the invoice documents of the installed solar panels, while the roofing company has to confirm that they have actually installed solar panels at the citizen's address.
Once the invoice and the confirmation are there, the tax officer has to approve the request (\cref{fig:taxman-officer-approve}).
The officer can always decline the request, but they can only approve it if the roofing company has confirmed and the application date is within one year of the invoice date (\cref{fig:taxman-officer-approve-def}).
The result of the program is the amount of the subsidy, together with all information needed to prove the required properties (\cref{fig:taxman-result}).

The result of the overall task is a tuple with the subsidy amount, the officer's decision, the roofing company's confirmation, the invoice amount, the invoice date, and today's date.
Returning all this information allows the following predicate to be stated, which verifies the correctness of the implementation.
The predicate has 5 free variables, which correspond to the returned values.
\setcounter{equation}{0}
\begin{align}
\psi(s,d,c,a,i,t)
   & =      s \geq 0 \implies c \label{tax-psi-confirmed}
\\ & \wedge s \geq 0 \implies a \label{tax-psi-approved}
\\ & \wedge a \implies c \wedge t - i \leq 356 \label{tax-psi-approve-conditions}
\\ & \wedge s \leq 600 \label{tax-psi-max-subsidy}
\\ & \wedge \lnot a \implies s \equiv 0 \label{tax-psi-unapproved}
\end{align}
The predicate $\psi$ states that (\ref{tax-psi-confirmed}) if subsidy has been payed, the roofing company must have confirmed, (\ref{tax-psi-approved}) if subsidy has been payed, the officer must have approved, (\ref{tax-psi-approve-conditions}) the officer can approve only if the roofing company has confirmed and today's date is within 356 days of the invoice date, and (\ref{tax-psi-max-subsidy}) the subsidy is maximal 600 EUR.
Finally, (\ref{tax-psi-unapproved}) if the officer has not approved, the subsidy must be 0.



\subsection{Flight booking}

In this section we develop a small flight booking system.
The purpose of this example is to demonstrate how Symbolic TopHat handles references and lists.
We prove that when the program terminates, every passenger has exactly one seat, and that no two passengers have the same seat.
This program is a simplified version of what we presented in earlier work \cite{Steenvoorden2019}.

\begin{TASK}[float=h
            ,numbers=right
            ,caption=Flight booking.
            ,label=fig:flight-booking
            ]
  let maxSeats = 50 in
  let bookedSeats = ref [] in|\label{flight:make-ref}|
  let bookSeat = enter Int >>= \ x .|\label{flight:enter-seat-number}|
    if x `elem` !bookedSeats \/ x > maxSeats|\label{flight:guard-invalid-seats}|
      then fail else bookedSeats := x :: !bookedSeats in
  bookSeat <&> bookSeat <&> bookSeat >>= \ _ .|\label{flight:main-expression}|
  edit (!bookedSeats)
\end{TASK}

The program, shown in \cref{fig:flight-booking}, consists of three parallel seat booking tasks (\cref{flight:main-expression}).
There is a shared list that stores all seats that have been booked so far (\cref{flight:make-ref}).
In order to book a seat, a passenger has to enter a seat number (\cref{flight:enter-seat-number}).
A guard makes sure that only free seats can be booked (\cref{flight:guard-invalid-seats}).
The main expression runs the seat booking task three times in parallel (\cref{flight:main-expression}), simulating three concurrent customers.
The program returns the list of booked seats.

With the returned list, we can state the predicate to verify the correctness of the booking process.
\setcounter{equation}{0}
\begin{align}
\psi(l)
   & =      \Len l \equiv 3 \label{flight-psi-exactly-three-seats}
\\ & \wedge \Uniq l \label{flight-psi-unique-seats}
\end{align}
The predicate specifies that every passenger got exactly one seat (\ref{flight-psi-exactly-three-seats}), and that all seats are unique (\ref{flight-psi-unique-seats}), which means that no two passenger got the same seat.
The unary operators for list length ($\Len$) and uniqueness ($\Uniq$) are available in the predicate language.
List length is a capability of \SMTLIB, while $\Uniq$ is our own addition.
