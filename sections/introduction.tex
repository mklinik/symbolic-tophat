% !TEX root=../main.tex



\section{Introduction}

The Task Oriented Programming paradigm (\TOP) is a useful abstraction over worflow programs.
The idea of \TOP is to describe what work needs to be done, in what order.
Then from this specification, the whole system can be generated.
The iTasks framework~\cite{DBLP:conf/ppdp/PlasmeijerLMAK12} is an implementation of the paradigm in the functional programming language Clean.
The many applications developed in the iTasks framework clearly demonstrate the usefullness and need for this new programming paradigm.

It is being used by the Netherlands Royal Navy~\cite{jansen2018dynamic}, Dutch Tax Office~\cite{conf/sfp/StutterheimAP17} and the Dutch Coastal Guard~\cite{lijnse2012incidone}. % of moeten we hier verwijzen naar Consequence Management â€“ Declarative Modelling of Maritime C2-systems
Furthermore, it has potential for application in domains like health-care and IoT~\cite{DBLP:conf/cgo/KoopmanLP18}.
Applications used in these type of domains and by these kind of organisations are often critical, where programming mistakes can have huge consequences.
Currently, iTasks programs are verified by running manually written test-cases. % do we have a source?
It is evident that testing alone is not sufficient.

In this paper we propose a more formal approach to verification.
By means of symbolic execution, we can guarantee that certain conditions over the outcome of a \TOP program hold.
Since iTasks does not have a formal semantics, we instead apply symbolic execution to \TOPHAT~\cite{Steenvoorden2019}.
This \TOP implementation does have a formal semantics, and is therefore suitable for formal verification.

\subsection{Contributions}

\begin{itemize}
  \item Symbolic execution semantics for \TOPHAT
  \item Soundness and completeness proof of the symbolic semantics with respect to \TOPHAT
  \item Implementation in Haskell of the symbolic execution semantics
\end{itemize}

\subsection{Scope}

In other work on symbolic execution semantics, it is often possible to write in-program assertions.
These assertions are verified using the path and input constraints, and the analysis returns which assertions have been violated.
In this paper, we limit ourselves to one general predicates over all end states instead.
This requires minimal changes to the existing semantics, but is equally as powerful.
Assertions can be easily rewritten, as demonstrated in section~\ref{}.\todo{state this somewhere?}

We also limit ourselves to predicates that must hold, regardless of the input.
In the future, we would like to support predicates that depend on the specific input.
The outlook of our work on symbolic execution semantics is further described in Section~\ref{subsec:outlook}.


\subsection{Structure}
Section~\ref{sec:examples} will give a brief overview of \TOPHAT and introduce two examples to demonstrate the goal of our analysis.
Section~\ref{sec:intuition} describes the intuition behind symbolic execution and how it is applied to \TOPHAT.
Then in Section~\ref{sec:language}, the \TOPHAT language is defined.
Section~\ref{sec:semantics} goes on to define the formal semantics of the symbolic execution.
In Section~\ref{sec:properties}, soundness and completeness is shown for the symbolic execution semantics with respect to the original \TOPHAT semantics.
Then in Section~\ref{sec:relatedwork} related work is discussed, and Section~\ref{sec:conclusion} concludes.
