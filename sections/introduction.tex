% !TEX root=../main.tex



\section{Introduction}

The Task Oriented Programming paradigm (\TOP) is a useful abstraction over worflow programs.
The idea of \TOP is to describe what work needs to be done, in what order.
Then from this specification, the whole system can be generated.
The iTasks framework~\cite{DBLP:conf/ppdp/PlasmeijerLMAK12} is an implementation of the paradigm in the functional programming language Clean.
The many applications developed in the iTasks framework clearly demonstrate the usefullness and need for this new programming paradigm.

It is being used by the Netherlands Royal Navy~\cite{jansen2018dynamic}, Dutch Tax Office~\cite{conf/sfp/StutterheimAP17} and the Dutch Coastal Guard~\cite{lijnse2012incidone}. % of moeten we hier verwijzen naar Consequence Management â€“ Declarative Modelling of Maritime C2-systems
Furthermore, it has potential for application in domains like health-care and IoT~\cite{DBLP:conf/cgo/KoopmanLP18}.
Applications used in these type of domains and by these kind of organisations are often critical, where programming mistakes can have huge consequences.
Currently, iTasks programs are verified by running manually written test-cases. % do we have a source?
It is evident that testing alone is not sufficient.

In this paper we propose a more formal approach to verification.
By means of symbolic execution, we can guarantee that certain conditions over the outcome of a \TOP program hold.
Since iTasks does not have a formal semantics, we instead apply symbolic execution to \TOPHAT~\cite{Steenvoorden2019}.
This \TOP implementation does have a formal semantics, and is therefore suitable for formal verification.

\subsection{Contributions}

\begin{itemize}
  \item Symbolic execution semantics for \TOPHAT
  \item Soundness and completeness proof of the symbolic semantics with respect to \TOPHAT
  \item Implementation in Haskell of the symbolic execution semantics
\end{itemize}

\subsection{Scope}

We limit ourselves to predicates over task results that must hold for all possible inputs.
In the future, we would also like to be able to prove statements for certain inputs.
\fixme{more on this}

\subsection{Structure}
Section~\ref{sec:examples} will give a brief overview of \TOPHAT and introduce two examples to demonstrate the goal of our analysis.
Section~\ref{sec:intuition} describes the intuition behind symbolic execution and how it is applied to \TOPHAT.
Then in Section~\ref{sec:language}, the \TOPHAT language is defined.
Section~\ref{sec:semantics} goes on to define the formal semantics of the symbolic execution.
In Section~\ref{sec:properties}, soundness and completeness is shown for the symbolic execution semantics with respect to the original \TOPHAT semantics.
Then in Section~\ref{sec:relatedwork} related work is discussed, and Section~\ref{sec:conclusion} concludes.
