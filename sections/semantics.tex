% !TEX root=../main.tex


\section{Semantics}
\label{sec:semantics}



\subsection{Observations}

\todo{Extend for read-only editors.}

\begin{center}
  \usemacro{O-Value}
\end{center}

\begin{center}
  \usemacro{O-Failing}
\end{center}

\usemacro{O-Inputs}

\fixme{Are these still correct?}



\subsection{Evaluation}

\todo{Add rules for $\Fst$ and $\Snd$.}

\begin{gather*}
  \boxed{\RelationE} \Break
  \userule{Sym-E-Value}\Quad
  \userule{Sym-E-Pair} \Break
  \userule{Sym-E-App} \Break
  \userule{Sym-E-If} \Break
  %\userule{Sym-E-IfTrue} \Break
  %\userule{Sym-E-IfFalse} \Break
  \userule{Sym-E-Ref} \Quad
  \userule{Sym-E-Deref} \Break
  \userule{Sym-E-Assign} \Break
  \userule{Sym-E-Edit} \Quad
  \userule{Sym-E-Enter}\Quad
  \userule{Sym-E-Update}\Break
  \userule{Sym-E-Then}\Quad
  \userule{Sym-E-Next}\Break
  \userule{Sym-E-And}\Break
  \userule{Sym-E-Or} \Break
  \userule{Sym-E-Xor}\Quad
  \userule{Sym-E-Fail}
\end{gather*}



\subsection{Normalisation}

\begin{gather*}
  \boxed{\RelationS} \Break
  \userule{Sym-S-ThenStay} \Break
  \userule{Sym-S-ThenFail} \Break
  \userule{Sym-S-ThenCont} \Break
  \userule{Sym-S-OrLeft} \Break
  \userule{Sym-S-OrRight} \Break
  \userule{Sym-S-OrNone} \Break
  \userule{Sym-S-Edit} \Quad
  \userule{Sym-S-Fill} \Break
  \userule{Sym-S-Update} \Quad
  \userule{Sym-S-Fail} \Break
  \userule{Sym-S-Xor} \Quad
  \userule{Sym-S-Next} \Break
  \userule{Sym-S-And}
\end{gather*}


\begin{gather*}
  \boxed{\RelationN} \Break
  \userule{Sym-N-Done} \Break
  \userule{Sym-N-Repeat}
\end{gather*}



\subsection{Handling}

\begin{gather*}
  \boxed{\RelationH} \Break
  \userule{Sym-H-Change} \Quad
  \userule{Sym-H-Fill} \Break
  \userule{Sym-H-Update}\Break
  \userule{Sym-H-Next} \Break
  \userule{Sym-H-PassThen} \Quad
  \userule{Sym-H-PassNext} \Break
  \userule{Sym-H-PickLeft} \Break
  \userule{Sym-H-PickRight}\Break
  \userule{Sym-H-Pick}\Break
  \userule{Sym-H-And}\Break
  \userule{Sym-H-Or}
\end{gather*}

Note that \refrule{Sym-H-Empty} is omitted as it does nothing useful for symbolic execution.


\begin{gather*}
  \boxed{\RelationI} \Break
  \userule{Sym-I-Handle}
\end{gather*}


\subsection{Driving}
\label{subsec:driving}

This section describes the top level symbolic execution function.

This function called drive, which takes $t,I,\sigma,\phi$, is recursively called to produce a list of end states an predicates.
We consider a task, state and predicate to be an end state if the task value can be observed, and the predicate is satisfiable.

A recursive call is terminated when one of the two stop conditions is met.

When the predicate cannot be satisfied, we know that all future steps won't be satisfiable either.
In fact, no future state will be satisfiable, and we can therefore safely remove it.

The second stop condition is when an execution does not alter anymore between steps.
In other words, the program is stuck, no value can be observed, an no value will ever be observed.

We prove that both criteria only remove paths that are invalid or infinite in Section~\ref{sec:properties}.


\begin{function}
  \signature{\mathit{drive} :: \Task \times [\mathrm{Inputs}] \times \mathrm{State} \times \mathrm{Predicate} \rightarrow [(\Task,[\mathrm{Inputs}],\mathrm{State},\mathrm{Predicate})]} \\
  \mathit{drive}\ t\ I\ \sigma \ \phi  = \mathit{map} \ (\mathit{concat . drive'}) (t,\sigma \drive{})\\
                \mathit{where}\ \mathit{drive'}\ t'\ i\ \sigma'\ \phi'=\\
                        \begin{array}{ll}
                          [\ ] & \neg \text{SAT } (\phi'\land\phi)\\
                  \relax [(t',I\oplus[i],\sigma',\phi\land\phi')] & \Value(t',\sigma') \equiv v \wedge \text{SAT } (\phi'\land\phi)\\
                  \relax [\ ]            & t' \equiv t \wedge \phi' \equiv \True \wedge \Value(t',\sigma') \equiv \bot\\
                        \mathit{drive}\ t'\ (I\oplus[i])\ \sigma'\ (\phi\land\phi') & (t' \neq t \vee \neg\phi') \wedge \Value(t',\sigma') \equiv \bot
                                  \end{array}
\end{function}

\begin{definition}[Satisfiability of predicates]
  \label{def:Sat}
  $\text{SAT }\phi \iff \exists M=[s_0\mapsto c_0,\cdots,s_n\mapsto c_n]. M\phi\equiv\True$
\end{definition}



\subsection{Solving}

\fixme{Something about SMT.}
