% !TEX root=../main.tex


\section{Semantics}
\label{sec:semantics}

In this section we discuss the symbolic execution semantics for \TOPHAT.
The structure of the symbolic semantics closely resembles that of the concrete semantics.
It consists of three main layers.
A big step symbolic evaluation semantics.
This corresponds with the host language.
A big step symbolic normalisation semantics at the task level.
And finally a small step driving semantics that processes user inputs one by one.

They are all listed in the coming sections.
Besides simply listing them, we will also point out what is interesting about them,
and what changes were made with respect to the concrete semantics.

\subsection{Symbolic evaluation}

The host language is a simply typed lambda calculus with references and basic operations.

%explain how we convert old rules to new rules.
Most of the symbolic evaluation rules closely resemble the concrete semantics.
Figure~\ref{fig:oldToNewSemantics} lists one rule from the concrete semantics and its corresponding symbolic rule to illustrate how to convert one to the other.

\begin{figure}[h]
  \small
  \begin{gather*}
    \userule{E-Edit}\Quad
    \userule{SE-Edit}
  \end{gather*}
  \caption{The evaluation rule from the concrete and the symbolic semantics for the editor expression}
  \label{fig:oldToNewSemantics}
\end{figure}

The \refrule{E-Edit} rule evaluates the expression held in an editor to a value.
The \refrule{SE-Edit} does the same, but since we are doing a symbolic execution, the expression could contain symbols.
We therefore do not know beforehand which concrete value will be produced, or even which path the execution will take.
If the expression contains a conditional that depends on a symbol, it is possible that there are multiple result values, instead of just one.
This is denoted in the evaluation with a line over the result, which can be read as $\overline{v,\sigma',\phi} = \{(v_1,\sigma'_1,\phi_1),\cdots,(v_n,\sigma'_n,\phi_n)\}$.

Figure~\ref{fig:eval} lists the rule for conditional.
From this rule, one can clearly see that both branches are calculated, since at this point we do not know, what the condition will evaluate to.
Note that both $e_2$ and $e_3$ are evaluated using the same state $\sigma'$,
which is the resulting state after evaluating $e_1$.
Threading $\sigma''$ through the evaluation of $e_3$ would violate soundness with respect to the original semantics (see also \cref{sec:soundess}).

The set that results from the symbolic execution can be interpreted as follows.
Each element is a possible (end)point in the execution of a task.
It is guarded by a condition $\phi$ over the symbolic input.
Only if $\phi$ holds, can we arrive at the value $v$ and state $\sigma'$.

As mentioned, the symbolic rules closely resemble the concrete semantics.
They follow directly from the concrete semantics, as described above.
Therefore, they are not listed here, but a full overview of the rules can be found in the appendix.
One rule does differ, which is listed in Figure~\ref{fig:eval}.

\begin{figure}[h]
  \small
  \begin{gather*}
    \boxed{\RelationSE} \Break
    \userule{SE-If}
  \end{gather*}
  \caption{Part of the symbolic evaluation semantics}
  \label{fig:eval}
\end{figure}

Instead of two separate rules, one for the then and one for the else branch, we now have one \refrule{SE-If rule}.
Since $e_1$ can contain symbols, it could very well be that we are unable to determine what value the condition evaluates to.
Instead, we keep both options open.

We calculate the then-branch, and add to the path condition that we can only reach this point if $v_1$ becomes $\True$.
And we do the same for the else-branch, except we now require that $v_1$ has to become $\False$, in order for this result to apply.

\subsection{Observations}
\label{subsec:observations}
The symbolic normalisation and driving semantics make use of observations on tasks.
This is no different from how the concrete \TOPHAT semantics works.

We can observe the value of a task using the partial function $\Value$.
Its definition is given in Figure~\ref{fig:value}, which is unchanged with respect to the original.

\begin{figure}[h]
  \small
  \begin{center}
    \usemacro{O-Value}
  \end{center}
  \caption{Task value observation function $\Value$}
  \label{fig:value}
\end{figure}

We can observe if a task is failing using the function $\Failing$.
Its definition is given in Figure~\ref{fig:failing}.
Checking if an user choice is failing changes due to the usage of symbolic normalisation.
Symbolic normalisation possibly yields multiple results.
Each of these results should be failing to make an user choice failing.

\begin{figure}[h]
  \small
  \begin{center}
    \usemacro{O-Failing}
  \end{center}
  \caption{Task failing observation function $\Failing$}
  \label{fig:failing}
\end{figure}

\subsection{Normalisation}

The normalisation semantics prepares tasks to receive input.
Very little changes had to be made to these semantics in order to accommodate symbolic execution.

Just as with the evaluation semantics, we now gather sets of results, each guarded by a path condition on the symbolic input.

Figure~\ref{fig:normalising} lists the normalisation semantics.
For the striding semantics, we refer to the appendix.



\begin{figure*}
  \small
  \begin{gather*}
    \boxed{\RelationSN} \Break
    \userule{SN-Done} \Quad
    \userule{SN-Repeat}
  \end{gather*}
  \caption{Symbolic normalisation semantics}
  \label{fig:normalising}
\end{figure*}


\subsection{Handling}

The handling semantics deals with user input, in the case of \TOPHAT.
When dealing with symbolic execution, of course there is no user input.
Instead, we enter in symbols, where user input is expected.
The result of the semantics now also lists the symbol that was entered.

Figure~\ref{fig:handling} lists the interesting rules of the symbolic handling semantics.
A complete overview of the rules can be found in the appendix.

\begin{figure*}
  \small
  \begin{gather*}
    \boxed{\RelationSH} \Break
    \userule{SH-Change} \Quad
    \userule{SH-Fill} \Quad
    \userule{SH-Update}\Break
    \userule{SH-Next} \Quad
    \userule{SH-PickLeft} \Break
    \userule{SH-PickRight}\Quad
    \userule{SH-Pick}\Break
    \userule{SH-And}\Quad
    \userule{SH-Or}
  \end{gather*}
  \caption{Symbolic execution rules for the handling semantics}
  \label{fig:handling}
\end{figure*}

The three rules for the editors clearly show how symbols are entered into the symbolic execution.
The \refrule{SH-Fill} rule for example, generates a fresh symbol $s$, and then returns an editor containing that symbol.

There are several task combinators where the result depends on the user input.
For example, the parallel combinator $\And$ receives an input for either the left or the right branch.
To accommodate for all possibilities, the \refrule{SH-And} rule generates both cases.
It tags the inputs for the first branch with $\First$ and inputs for the second branch with $\Second$.

The same principle applies to the external choice combinator $\Xor$, however, in this case, we still need three rules.
This is due to the fact that users are not allowed to step to a task that is failing.
Therefore, we have one rule for the case where none of the options are failing, one rule when only the right fails and one rule for the case where the left is failing.


\begin{figure}
  \small
  \begin{gather*}
    \boxed{\RelationSI} \Break
    \userule{SI-Handle}
  \end{gather*}
  \caption{Symbolic driving semantics}
  \label{fig:driving}
\end{figure}

After input has been handled, tasks are normalised.
The combination of those two steps is taken care of by the driving semantics, listed in Figure~\ref{fig:driving}.


\subsection{Simulating}
\label{subsec:driving}

The symbolic execution semantics listed above is a small step semantics:
each time it is executed, it simulates one symbolic user input.
In order to compute every possible symbolic execution, the driving semantics needs to be applied repeatedly, until the task is \emph{done}.
We define a task to be done, when it has an observable value.
The simulation function listed in Figure~\ref{fig:simulate}, is recursively called to produce a list of end states and path conditions.
It accumulates all symbolic user inputs and returns the observable task value $v$, the path condition $\phi$, and the current state $\sigma$.
We consider a task, state and path condition to be an end state if the task value can be observed, and the path condition is satisfiable.
A recursive call is terminated when one of the following conditions is met.

\begin{description}
  \item[$\Sat(\phi)$]
    When the path condition cannot be satisfied, we know that all future steps will not be satisfiable either.
    In fact, no future path condition will be satisfiable, and we can therefore safely remove it.

  \item[$\Value(t,\sigma)$]
    When the current task produces a value, we are at an endpoint, which we can return.

  \item[$\Value(t',\sigma')=\bot\land t=t'\land \neg \mathit{again}$]
    When the current task does not produce a value, and then it is equal to the previous task, apart from symbol names in editors, the simulate function performs one look-ahead step in case the task is waiting for an independent symbol.
    This one step look-ahead is encoded by the $\mathit{again}$-parameter.
    When this parameter is set to $\False$, one step look-ahead has been performed and simulate does not continue further.
    If a value is found, it is returned, otherwise the branch that is being explored will be pruned.
\end{description}
%We prove that both criteria only remove paths that are invalid or infinite in Section~\ref{sec:properties}.

\begin{figure*}
  \begin{function}
    \signature{\mathit{simulate} : \mathrm{Tasks} \times \mathrm{States} \times [\mathrm{Inputs}]  \times \mathrm{Predicates}
      \rightarrow \powerset{\mathrm{Valuse} \times [\mathrm{Inputs}] \times \mathrm{Predicates}}} \\
    \mathit{simulate}(t, \sigma, I, \phi) &=&
      \bigcup \set{ \mathit{simulate'}(\True, t, I, \phi, t', \sigma', i', \phi') \mid t, \sigma \drive{} t', \sigma', i', \phi' } \\
    \addlinespace
    \signature{\mathit{simulate'} : \mathrm{Booleans} \times \mathrm{Tasks} \times [\mathrm{Inputs}] \times \mathrm{Predicates} \times \mathrm{Tasks} \times \mathrm{States} \times \mathrm{Inputs} \times \mathrm{Predicates}
      \rightarrow \powerset{\mathrm{Values} \times [\mathrm{Inputs}] \times \mathrm{Predicates}}} \\
    \mathit{simulate'}(\mathit{again}, t, I, \phi, t', i', \sigma', \phi') &=& \\
      \multicolumn{3}{L}{ \left\{
        \begin{array}{lrclclcr}
          \nothing                                                                                              & \neg\Sat(\phi'\land\phi) &&&&&&\\
          \set{(v, I\oplus[i'], \phi\land\phi')}                                                                & \Sat(\phi'\land\phi)     &\land& \Value(t',\sigma') = v &&&& \\
          \mathit{simulate}(t', \sigma', I\oplus[i'], \phi\land\phi')                                           & \Sat(\phi'\land\phi)     &\land& \Value(t',\sigma') = \bot &\land& t' \neq t &&\\
          \bigcup \set{\mathit{simulate'}(\False, t', I\oplus[i'], \phi\land\phi', t'', \sigma'', i'', \phi'')
            \mid  t',\sigma' \drive{} t'', \sigma'', i'', \phi''}                                               & \Sat(\phi'\land\phi)     &\land& \Value(t',\sigma') = \bot &\land& t' = t    &\land& \mathit{again}\\
          \nothing                                                                                              & \Sat(\phi'\land\phi)     &\land& \Value(t',\sigma') = \bot &\land& t' = t    &\land& \neg\mathit{again}
        \end{array}
        \right.}
  \end{function}
  \caption{Simulation function definition}
  \label{fig:simulate}
\end{figure*}

To better illustrate how the simulate function works, we apply it to Example~\ref{example:abs}.

\begin{figure*}
  \small

\tikzstyle{level 1}=[level distance=5cm, sibling distance=3cm]
\tikzstyle{level 2}=[level distance=5cm, sibling distance=3cm]


\tikzstyle{bag} = [text width=4em, text centered]
\tikzstyle{end} = [circle, minimum width=3pt,fill, inner sep=0pt]

\begin{tikzpicture}[grow=right, sloped]
\node[bag] {$i=s_0$}
    child[missing] {node {}}
    child {
        node[bag] {$i'=s_1$}
            child[missing] {node {}}
            child {
                node[bag] {$i''=s_2$}
                child[missing] {node {}}
                child {
                    node[end, label=right:
                        {$\nothing$}] {}
                    edge from parent
                    node[above] {$\phi''=s_2\leq 0$}
                    node[below]  {\begin{tabular}{c} $\Value(\Edit s_0\Then\ldots,\sigma)=\bot$\\ $\Edit s_0 \Then\ldots = \Edit s_1\Then\ldots$\\ $\mathit{again}=\False$ \end{tabular}}
                }
                child {
                    node[end, label=right:
                        {\begin{tabular}{l} $s_2$\\ $[s_0,s_1,s_2]$\\ $s_0\leq 0\land s_1\leq 0\land s_2>0$ \end{tabular}}] {}
                    edge from parent
                    node[above] {$\phi''=s_2>0$}
                    node[below]  {$\Value(\Edit s_2,\sigma)=s_2$}
                }
                edge from parent
                node[above] {$\phi'=s_1\leq0$}
                node[below]  {\begin{tabular}{c} $\Value(\Edit s_0\Then\ldots,\sigma)=\bot$\\ $\Edit s_0 \Then\ldots = \Edit s_1\Then\ldots$\\ $\mathit{again}=\True$\end{tabular}}
            }
            child {
                node[end, label=right:
                    {\begin{tabular}{l} $s_1$\\ $[s_0,s_1]$\\ $s_0\leq 0\land s_1>0$\end{tabular}}] {}
                edge from parent
                node[above] {$\phi'=s_1>0$}
                node[below]  {$\Value(\Edit s_1,\sigma)=s_1$}
            }
            edge from parent
            node[above] {$\phi=s_0\leq 0$}
            node[below]  {\begin{tabular}{c} $\Value(\Edit s_0\Then\ldots,\sigma)=\bot$\\ $\Enter \Int \Then\ldots\neq \Edit s_0\Then\ldots$\end{tabular}}
    }
    child {
        node[end, label=right:
            {\begin{tabular}{l} $s_0$\\ $[s_0]$\\ $s_0>0$\end{tabular}}] {}
        edge from parent
            node[above] {$\phi=s_0>0$}
            node[below]  {$\Value(\Edit s_0,\sigma)=s_0$}
    };
\end{tikzpicture}
\caption{Application of the simulation function to Example~\ref{example:abs}}
\label{diagram:simapp}
\end{figure*}

\fixme{What does this do here? --TS}
\begin{definition}[Satisfiability of predicates]
  \label{def:Sat}
  $\Sat(\phi)$ if and only if there exits a mapping $M=[s_0\mapsto c_0,\cdots,s_n\mapsto c_n]$ such that $M\phi\equiv\True$
\end{definition}

Figure~\ref{diagram:simapp} gives a schematic overview of the application of simulate to
Simulate will first call the drive semantics, to calculate what input the task takes.
Users can enter a fresh symbol $s_0$, as listed on the left.
The symbolic execution then branches, since we reach a conditional.
Two cases are generated. Either $s_0>0$, the upper branch, or $s_0\leq0$, the  branch to the right.
In the first case, the resulting task has a value, and the symbolic execution ends, returning that value, and the input observed.
In the second case, the resulting task does not have a value, and the new task is different from the previous task.
Therefore, we recurse, and simulate is called again.

We can now input a fresh symbol $s_1$. Again, $s_1$ can either be larger than zero, or smaller or equal.
In the first case, again the resulting task has a value, and the execution ends.
In the second case however, the task does not have a value, and we find that the task has not been altered (apart from the new symbol).
This will result in a recursive call to simulate', where we set the $\mathit{again}$-parameter to $\False$.

Again, we can input a fresh symbol $s_2$. And again, $s_2$ can be larger than zero, or smaller or equal to it.
In the first case, we have a value and we are done.
In the second case, we do not have a value, the task again has not changed, but the $\mathit{again}$-parameter is $\False$ and therefore, we do not proceed with the symbolic execution of this branch.

This example tells is a few things.
From manual inspection, it is clear that only the first iteration returns an interesting result.
When $s_0$ is larger than zero, the task results in a value, that is larger than zero.
When the input is smaller than or equal to zero, we can only input a new value, until that value is larger than zero.
So this means, we are back where we started from.
Why does the simulation still proceed then?
Since the editor $\Enter$ changes to $\Edit$, the tasks are not the same anymore.
This causes simulate to run an extra iteration.
Then, it finds that the task still does not return a value, but now, the tasks have changed.
Then the simulate function will perform one look-ahead step, by setting the $\mathit{again}$-parameter to $\False$.
When this look-ahead does not return a value, we close the branch.



\subsection{Solving}

To check the satisfiability $\Sat(\phi)$, as well as the properties stated about a program,
we make use of an external \SMT~solver.
In the implementation we use \ZTHREE,
although any other \SMT~solver supporting \SMTLIB could be used.

For Example~\ref{example:abs}, we would like to prove that after any interaction path $I$,
the path conditions $\phi$ imply that the value $v$ of the resulting task $t'$ is bigger than $0$, i.e:
\begin{equation*}
  \phi \implies v  > 0 \Quad \where v = \Value(t',\sigma')
\end{equation*}
As shown in Figure~\ref{diagram:simapp}, there are three paths we need to verify.
For each of the three paths,
therefore, we send the following three statements to the \SMT~solver for verification:
\begin{enumerate}
  \item $s_0 > 0                                   \implies s_0 > 0  $
  \item $s_0 \leq 0 \land s_1 > 0                  \implies s_1 > 0  $
  \item $s_0 \leq 0 \land s_1 \leq 0 \land s_2 > 0 \implies s_2 > 0  $
\end{enumerate}
In this example, all are trivially solvable.



\subsection{Implementation}

We implemented the presented language and its semantic rules in the functional programming language \HASKELL.
With help of a couple \GHC extensions, the grammar, typing rules and semantics are almost one-to-one translatable into code.
Our tool generates trees, like the one shown in Figure~\ref{diagram:simapp},
which keep track of intermediate normalisations, symbolic inputs, and path conditions.
All path conditions are converted to \SMTLIB compatible statements and verified using the \ZTHREE \SMT~solver.

As is usually the case with symbolic execution, the number of paths grow quickly.
\Cref{exm:solar-subsidy} and \cref{exm:flight-booking} generate respectively 2112 and 1166 paths,
which take about a minute to calculate.
Solving them, however, is almost instantaneous.



\subsection{Outlook}
\label{subsec:outlook}

As mentioned in the introduction, other work on symbolic execution often uses assertions written by the programmer in the program.

\begin{example}
  Consider the following small example program.
  \begin{TASK}
    enter Int >>= \ x . edit (ref x ) >>= \ l. assert (!l == x) (edit "Done")
  \end{TASK}

  This program asks the user to enter an integer.
  The entered value is then stored in a reference.
  The assertion that follows, ensures that the store holds the correct value.
  Afterwards, the string "Done" is returned to the user.
\end{example}

The assertion in the example above has access to all variables that are in scope.
This is not the case when programmers are only allowed to define properties over the resulting value of tasks.
We can overcome this however, by returning the values we are interested in at the end of the program.

\begin{TASK}
  enter Int >>= \ x . edit (ref x ) >>= \ store . edit "Done" >>= \ _ . edit (x,!store)
\end{TASK}

We can now verify that the property $\lambda v . \Fst v = \Snd v$ holds.

This shows that our approach as the same power as using assertions.

We would like to extend our symbolic execution with assertions however.
This is much more convenient for programmers to use.

Another feature we would like to support in the future, is input dependent predicates.

\begin{example}
  Consider the following small program.

  \begin{TASK}
    enter Int >>= \ x . if x>0 then edit "Thank you" else edit "error"
  \end{TASK}

  The user inputs an integer.
  If the integer is larger than zero, we print a thank you message.
  If the integer is smaller than zero, an error is returned.

  If we wanted to prove that, given a positive input, the program never returns "error", we need to be able to include the input in our predicate.
\end{example}

Currently our symbolic execution does not support this feature, but this is definitely future work.
