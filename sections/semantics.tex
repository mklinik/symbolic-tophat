% !TEX root=../main.tex

\section{Semantics}
\label{sec:semantics}

In this section we discuss the symbolic execution semantics for \TOPHAT.
The structure of the symbolic semantics closely resembles that of the concrete semantics.
It consists of three main layers.
\begin{enumerate*}
  \item A big step symbolic evaluation semantics.
  This corresponds with the host language.
  \item A big step symbolic normalisation semantics at the task level.
  And finally
  \item a small step driving semantics that processes user inputs one by one.
\end{enumerate*}

They are all listed in the coming sections.
Besides simply listing them, we will also point out what is interesting about them,
and what changes were made with respect to the concrete semantics.



\subsection{Symbolic evaluation}

The host language is a simply typed lambda calculus with references and basic operations.
Most of the symbolic evaluation rules closely resemble the concrete semantics.
The original evaluation relation ($\hat{\eval}$) had the form $\RelationE$,
where an expression $e$ in a state $\hat{\sigma}$ evaluates to a value $\hat{v}$ in state $\hat{\sigma}'$.
The hat distinguishes the old concrete and the new symbolic variants.
The new relation ($\eval$) adds path conditions $\phi$ to the output and reads $\RelationSE$.

Note that in the symbolic case, it is possible to generate multiple outcomes.
This is denoted in the evaluation with a line over the result, which can be read as $\overline{v,\sigma',\phi} = \{(v_1,\sigma'_1,\phi_1),\cdots,(v_n,\sigma'_n,\phi_n)\}$.
The set that results from the symbolic execution can be interpreted as follows.
Each element is a possible (end)point in the execution of a task.
It is guarded by a condition $\phi$ over the symbolic input.
Only if $\phi$ holds, can we arrive at the value $v$ and state $\sigma'$.

\begin{figure}[h]
  \small
  \begin{gather*}
    \userule{E-Edit}\Quad
    \userule{SE-Edit}
  \end{gather*}
  \caption{The evaluation rule from the concrete and the symbolic semantics for the editor expression}
  \label{fig:oldToNewSemantics}
\end{figure}

Figure~\ref{fig:oldToNewSemantics} lists one rule from the concrete semantics and its corresponding symbolic rule to illustrate how to convert one to the other.
The \refrule{E-Edit} rule evaluates the expression held in an editor to a value.
The \refrule{SE-Edit} does the same, but since we are doing a symbolic execution, the expression could contain symbols.
We therefore do not know beforehand which concrete value will be produced, or even which path the execution will take.
If the expression contains a conditional that depends on a symbol, it is possible that there are multiple result values, instead of just one.

% Figure~\ref{fig:eval} lists the rule for conditional.
% From this rule, one can clearly see that both branches are calculated, since at this point we do not know, what the condition will evaluate to.

As mentioned, the symbolic rules closely resemble the concrete semantics.
They follow directly from the concrete semantics, as described above.
Therefore, they are not listed here, but a full overview of the rules can be found in the appendix.
One rule does differ.
This is the rule for $\If{-}{-}{}$ and is listed in Figure~\ref{fig:eval}.

\begin{figure}[h]
  \small
  \begin{gather*}
    \boxed{\RelationSE} \Break
    \userule{SE-If}
  \end{gather*}
  \caption{Part of the symbolic evaluation semantics}
  \label{fig:eval}
\end{figure}

Instead of two separate rules, one for the $\THEN$ and one for the $\ELSE$ branch, we now have one \refrule{SE-If} rule.
Since $e_1$ can contain symbols, it could very well be that we are unable to determine what value the condition evaluates to.
Instead, we keep both options open.
We calculate the $\THEN$-branch, and add to the path condition that we can only reach this point if $v_1$ becomes $\True$.
And we do the same for the $\ELSE$-branch, except we now require that $v_1$ has to become $\False$, in order for this result to apply.
Note that both $e_2$ and $e_3$ are evaluated using the same state $\sigma'$,
which is the resulting state after evaluating $e_1$.
Threading $\sigma''$ through the evaluation of $e_3$ would violate soundness with respect to the original semantics (see also \cref{sec:soundess}).



\subsection{Observations}
\label{subsec:observations}

The symbolic normalisation and driving semantics make use of observations on tasks.
This is no different from how the concrete \TOPHAT semantics works.

We can observe the value of a task using the partial function $\Value$.
Its definition is given in Figure~\ref{fig:value}.
It is unchanged with respect to the original.

\begin{figure}[h]
  \small
  \begin{center}
    \usemacro{O-Value}
  \end{center}
  \caption{Task value observation functions $\Value$.}
  \label{fig:value}
\end{figure}

\begin{figure}[h]
  \small
  \begin{center}
    \usemacro{O-Failing}
  \end{center}
  \caption{Task failing observation function $\Failing$.}
  \label{fig:failing}
\end{figure}

\begin{figure*}[b]
  \begin{minipage}{\textwidth}
    \small
    \begin{gather*}
      \boxed{\RelationSN} \Break
      \userule{SN-Done} \Quad
      \userule{SN-Repeat}
    \end{gather*}
  \end{minipage}
  \caption{Symbolic normalisation semantics}
  \label{fig:normalising}
\end{figure*}

\begin{figure*}[b]
  \begin{minipage}{\textwidth}
    \small
    \begin{gather*}
      \boxed{\RelationSH} \Break
      \userule{SH-Change} \Quad
      \userule{SH-Fill} \Quad
      \userule{SH-Update}\Break
      \userule{SH-PickLeft} \Quad
      \userule{SH-PickRight} \Break
      \userule{SH-Pick} \Quad
      \userule{SH-Next} \Break
      \userule{SH-And}\Quad
      \userule{SH-Or}
    \end{gather*}
  \end{minipage}
  \caption{Symbolic handling semantics}
  \label{fig:handling}
\end{figure*}

We can observe if a task is failing using the function $\Failing$.
Its definition is given in Figure~\ref{fig:failing}.
A task is failing if it is the fail task ($\Fail$),
or if it consists of only failing tasks.
With respect to the original definition,
checking if an user choice is failing changes.
This is due to the usage of symbolic normalisation to peek into the future.
Symbolic normalisation possibly yields multiple results.
Therefore, each of these results should be failing to make an user choice failing.



\subsection{Normalisation}

The normalisation semantics prepares tasks to receive input.
Very little changes have to be made to these semantics in order to accommodate symbolic execution.
Just as with the evaluation semantics, we now gather sets of results, each guarded by a path condition on the symbolic input.
Figure~\ref{fig:normalising} lists the normalisation semantics.
For the striding semantics, we refer to the appendix.



\subsection{Handling}

The original handling semantics deal with user input.
In the symbolic case there is no user input.
We put symbols where user input is expected.
So, instead of having concrete events as the input of the handling semantics,
we now have symbolic events as outputs.
Figure~\ref{fig:handling} lists the interesting rules of the symbolic handling semantics.
A complete overview of the rules can be found in the appendix.

The three rules for the editors (\refrule{SH-Change}, \refrule{SH-Fill}, \refrule{SH-Update})
clearly show how symbols are entered into the symbolic execution.
The first one for example, generates a fresh symbol $s$, and then returns an editor containing that symbol.

There are several task combinators where the result depends on the user input.
For example, the parallel combinator ($\And$) receives an input for either the left or the right branch.
To accommodate for all possibilities, the \refrule{SH-And} rule generates both cases.
It tags the inputs for the first branch with $\First$ and inputs for the second branch with $\Second$.

The same principle applies to the external choice combinator ($\Xor$).
The three rules \refrule{SH-PickLeft}, \refrule{SH-PickRight}, and \refrule{SH-Pick}
are needed to disallow users to step to a failing task.
There is one rule for the case where only the right fails, one rule for the case where the left is failing, and one for the case none of the options are failing.

After input has been handled, tasks are normalised.
The combination of those two steps is taken care of by the driving semantics, listed in Figure~\ref{fig:driving}.

\begin{figure}[h]
  \small
  \begin{gather*}
    \boxed{\RelationSI} \Break
    \userule{SI-Handle}
  \end{gather*}
  \caption{Symbolic driving semantics}
  \label{fig:driving}
\end{figure}



\begin{figure*}[t]
  \begin{function}
    \signature{\Simulate : \mathrm{Tasks} \times \mathrm{States} \times [\mathrm{Inputs}]  \times \mathrm{Predicates}
      \rightarrow \powerset{\mathrm{Valuse} \times [\mathrm{Inputs}] \times \mathrm{Predicates}}} \\
    \Simulate(t, \sigma, I, \phi) &=&
      \bigcup \set{ \Simulate'(\True, t, I, \phi, t', \sigma', i', \phi') \mid t, \sigma \drive{} t', \sigma', i', \phi' } \\
    \addlinespace
    \signature{\Simulate' : \mathrm{Booleans} \times \mathrm{Tasks} \times [\mathrm{Inputs}] \times \mathrm{Predicates} \times \mathrm{Tasks} \times \mathrm{States} \times \mathrm{Inputs} \times \mathrm{Predicates}
      \rightarrow \powerset{\mathrm{Values} \times [\mathrm{Inputs}] \times \mathrm{Predicates}}} \\
    \Simulate'(\Again, t, I, \phi, t', i', \sigma', \phi') &=& \\
      \multicolumn{3}{L}{ \left\{
        \begin{array}{lrclclcr}
          \nothing                                                                                              & \neg\Sat(\phi'\land\phi) &&&&&&\\
          \set{(v, I\oplus[i'], \phi\land\phi')}                                                                & \Sat(\phi'\land\phi)     &\land& \Value(t',\sigma') = v &&&& \\
          \Simulate(t', \sigma', I\oplus[i'], \phi\land\phi')                                           & \Sat(\phi'\land\phi)     &\land& \Value(t',\sigma') = \bot &\land& t' \neq t &&\\
          \bigcup \set{\Simulate'(\False, t', I\oplus[i'], \phi\land\phi', t'', \sigma'', i'', \phi'')
            \mid  t',\sigma' \drive{} t'', \sigma'', i'', \phi''}                                               & \Sat(\phi'\land\phi)     &\land& \Value(t',\sigma') = \bot &\land& t' = t    &\land& \Again\\
          \nothing                                                                                              & \Sat(\phi'\land\phi)     &\land& \Value(t',\sigma') = \bot &\land& t' = t    &\land& \neg\Again
        \end{array}
        \right.}
  \end{function}
  \caption{Simulation function definition}
  \label{fig:simulate}
\end{figure*}

\begin{figure*}
  \small
\tikzstyle{level 1}=[level distance=5cm, sibling distance=3cm]
\tikzstyle{level 2}=[level distance=5cm, sibling distance=3cm]
\tikzstyle{bag} = [text width=4em, text centered]
\tikzstyle{end} = [circle, minimum width=3pt,fill, inner sep=0pt]
\begin{tikzpicture}[grow=right, sloped]
\node[bag] {$i=s_0$}
    child[missing] {node {}}
    child {
        node[bag] {$i'=s_1$}
            child[missing] {node {}}
            child {
                node[bag] {$i''=s_2$}
                child[missing] {node {}}
                child {
                    node[end, label=right:
                        {$\nothing$}] {}
                    edge from parent
                    node[above] {$\phi''=s_2\leq 0$}
                    node[below] {\begin{tabular}{R@{\ }C@{\ }L}
                      \Value(\Edit s_0\Then\ldots,\sigma) &=& \bot \\
                      \Edit s_0 \Then\ldots               &=&  \Edit s_1\Then\ldots \\
                      \Again                              &=& \False
                    \end{tabular}}
                }
                child {
                    node[end, label=right:
                        {\begin{tabular}{l} $s_2$\\ $[s_0,s_1,s_2]$\\ $s_0\leq 0\land s_1\leq 0\land s_2>0$ \end{tabular}}] {}
                    edge from parent
                    node[above] {$\phi''=s_2>0$}
                    node[below]  {$\Value(\Edit s_2,\sigma)=s_2$}
                }
                edge from parent
                node[above] {$\phi'=s_1\leq0$}
                node[below] {\begin{tabular}{R@{\ }C@{\ }L}
                  \Value(\Edit s_0\Then\ldots,\sigma) &=& \bot \\
                  \Edit s_0 \Then\ldots               &=&  \Edit s_1\Then\ldots \\
                  \Again                              &=& \True
                \end{tabular}}
            }
            child {
                node[end, label=right:
                    {\begin{tabular}{l} $s_1$\\ $[s_0,s_1]$\\ $s_0\leq 0\land s_1>0$\end{tabular}}] {}
                edge from parent
                node[above] {$\phi'=s_1>0$}
                node[below]  {$\Value(\Edit s_1,\sigma)=s_1$}
            }
            edge from parent
            node[above] {$\phi=s_0\leq 0$}
            node[below] {\begin{tabular}{R@{\ }C@{\ }L}
              \Value(\Edit s_0\Then\ldots,\sigma) &=   & \bot \\
              \Enter \Int \Then\ldots             &\neq& \Edit s_0\Then\ldots
            \end{tabular}}
    }
    child {
        node[end, label=right:
            {\begin{tabular}{l} $s_0$\\ $[s_0]$\\ $s_0>0$\end{tabular}}] {}
        edge from parent
            node[above] {$\phi=s_0>0$}
            node[below]  {$\Value(\Edit s_0,\sigma)=s_0$}
    };
\end{tikzpicture}
\caption{Application of the simulation function to \cref{lst:abs}}
\label{diagram:simapp}
\end{figure*}



\subsection{Simulating}
\label{subsec:driving}

The symbolic execution semantics listed above is a small step semantics:
each time it is executed, it simulates one symbolic user input.
In order to compute every possible symbolic execution, the driving semantics needs to be applied repeatedly, until the task is \emph{done}.
We define a task to be done, when it has an observable value.
The simulation function listed in Figure~\ref{fig:simulate}, is recursively called to produce a list of end states and path conditions.
It accumulates all symbolic user inputs and returns the observable task value $v$, the path condition $\phi$, and the current state $\sigma$.
We consider a task, state and path condition to be an end state if the task value can be observed, and the path condition is satisfiable.
A recursive call is terminated when one of the following conditions is met.

\begin{description}
  \item[$\Sat(\phi)$]
    When the path condition cannot be satisfied, we know that all future steps will not be satisfiable either.
    In fact, no future path condition will be satisfiable, and we can therefore safely remove it.

  \item[$\Value(t,\sigma)$]
    When the current task produces a value, we are at an endpoint, which we can return.

  \item[$\Value(t',\sigma')=\bot\land t=t'\land \neg \mathit{again}$]
    When the current task does not produce a value, and then it is equal to the previous task, apart from symbol names in editors, the simulate function performs one look-ahead step in case the task is waiting for an independent symbol.
    This one step look-ahead is encoded by the $\mathit{again}$-parameter.
    When this parameter is set to $\False$, one step look-ahead has been performed and simulate does not continue further.
    If a value is found, it is returned, otherwise the branch that is being explored will be pruned.
\end{description}
%We prove that both criteria only remove paths that are invalid or infinite in Section~\ref{sec:properties}.

To better illustrate how the simulate function works, we apply it to Example~\ref{example:abs}.

\fixme{What does this do here? --TS}
\begin{definition}[Satisfiability of predicates]
  \label{def:Sat}
  $\Sat(\phi)$ if and only if there exits a mapping $M=[s_0\mapsto c_0,\cdots,s_n\mapsto c_n]$ such that $M\phi\equiv\True$
\end{definition}

Figure~\ref{diagram:simapp} gives a schematic overview of the application of simulate to
Simulate will first call the drive semantics, to calculate what input the task takes.
Users can enter a fresh symbol $s_0$, as listed on the left.
The symbolic execution then branches, since we reach a conditional.
Two cases are generated. Either $s_0>0$, the upper branch, or $s_0\leq0$, the  branch to the right.
In the first case, the resulting task has a value, and the symbolic execution ends, returning that value, and the input observed.
In the second case, the resulting task does not have a value, and the new task is different from the previous task.
Therefore, we recurse, and simulate is called again.

We can now input a fresh symbol $s_1$. Again, $s_1$ can either be larger than zero, or smaller or equal.
In the first case, again the resulting task has a value, and the execution ends.
In the second case however, the task does not have a value, and we find that the task has not been altered (apart from the new symbol).
This will result in a recursive call to simulate', where we set the $\mathit{again}$-parameter to $\False$.

Again, we can input a fresh symbol $s_2$. And again, $s_2$ can be larger than zero, or smaller or equal to it.
In the first case, we have a value and we are done.
In the second case, we do not have a value, the task again has not changed, but the $\mathit{again}$-parameter is $\False$ and therefore, we do not proceed with the symbolic execution of this branch.

This example tells is a few things.
From manual inspection, it is clear that only the first iteration returns an interesting result.
When $s_0$ is larger than zero, the task results in a value, that is larger than zero.
When the input is smaller than or equal to zero, we can only input a new value, until that value is larger than zero.
So this means, we are back where we started from.
Why does the simulation still proceed then?
Since the editor $\Enter$ changes to $\Edit$, the tasks are not the same anymore.
This causes simulate to run an extra iteration.
Then, it finds that the task still does not return a value, but now, the tasks have changed.
Then the simulate function will perform one look-ahead step, by setting the $\mathit{again}$-parameter to $\False$.
When this look-ahead does not return a value, we close the branch.



\subsection{Solving}

To check the satisfiability $\Sat(\phi)$, as well as the properties stated about a program,
we make use of an external \SMT~solver.
In the implementation we use \ZTHREE,
although any other \SMT~solver supporting \SMTLIB could be used.

For Example~\ref{example:abs}, we would like to prove that after any interaction path $I$,
the path conditions $\phi$ imply that the value $v$ of the resulting task $t'$ is bigger than $0$, i.e:
\begin{equation*}
  \phi \implies v  > 0 \Quad \where v = \Value(t',\sigma')
\end{equation*}
As shown in Figure~\ref{diagram:simapp}, there are three paths we need to verify.
For each of the three paths,
therefore, we send the following three statements to the \SMT~solver for verification:
\begin{enumerate}
  \item $s_0 > 0                                   \implies s_0 > 0  $
  \item $s_0 \leq 0 \land s_1 > 0                  \implies s_1 > 0  $
  \item $s_0 \leq 0 \land s_1 \leq 0 \land s_2 > 0 \implies s_2 > 0  $
\end{enumerate}
In this example, all are trivially solvable.



\subsection{Implementation}

We implemented our language and its symbolic execution semantics in \HASKELL.
With the help of a couple \GHC extensions, the grammar, typing rules and semantics are almost one-to-one translatable into code.
Our tool generates execution trees, like the one shown in Figure~\ref{diagram:simapp},
which keep track of intermediate normalisations, symbolic inputs, and path conditions.
All path conditions are converted to \SMTLIB compatible statements and are verified using the \ZTHREE \SMT~solver.
As of now we do not have a parser, programs must be specified directly as abstract syntax trees.

As is usually the case with symbolic execution, the number of paths grows quickly.
The examples in \cref{fig:thetaxman,fig:flight-booking} generate respectively 2112 and 1166 paths,
which takes about a minute to calculate.
Solving them, however, is almost instantaneous.



\subsection{Outlook}
\label{subsec:outlook}


\paragraph{Scope}

In other work on symbolic execution semantics, it is often possible to write in-program assertions.
These assertions are verified using the path and input constraints, and the analysis returns which assertions have been violated.
In this paper, we limit ourselves to one general predicates over all end states instead.
This requires minimal changes to the existing semantics, but is equally as powerful.
Assertions can be easily rewritten, as demonstrated in Section~\ref{subsec:outlook}.

We also limit ourselves to predicates that must hold, regardless of the input.
In the future, we would like to support predicates that depend on the specific input.
The outlook of our work on symbolic execution semantics is further described in Section~\ref{subsec:outlook}.

\paragraph{Assertions}
Other work on symbolic execution often uses assertions, which are included in the program itself.
One could imagine an assertion statement \TS{assert $\psi$ t} in \TOPHAT that roughly works as follows.
First the \SAT solver verifies the property $\psi$ against the current path condition.
If the assertion fails, an error message is generated.
Then the program continues with task $t$.

\begin{example}
  Consider the following small example program.
  \begin{TASK}
    enter Int >>= \ x . edit (ref x ) >>= \ l. assert (!l == x) (edit "Done")
  \end{TASK}

  This program asks the user to enter an integer.
  The entered value is then stored in a reference.
  The assertion that follows ensures that the store has been updated correctly.
  Finally the string "Done" is returned.
\end{example}

Assertions have access to all variables in scope, unlike properties as we have currently implemented them.
We can overcome this by returning all values we are interested in at the end of the program.
\begin{TASK}
  enter Int >>= \ x . edit (ref x ) >>= \ store . edit "Done" >>= \ _ . edit (x,!store)
\end{TASK}
We can now verify that the property $\psi(v) = \Fst v \equiv \Snd v$ holds.
This demonstrates that our approach has expressive power similar to assertions.
Having assertions in our language would be more convenient for programmers however, and we would like add them in the future.

\paragraph{Input-dependent predicates}
Another feature we would like to support in the future are input-dependent predicates.

\begin{example}
  Consider the following small program.

  \begin{TASK}
    enter Int >>= \ x . if x > 0 then edit "Thank you" else edit "Error"
  \end{TASK}

  The user inputs an integer.
  If the integer is larger than zero, the program prints a thank you message.
  If the integer is smaller than zero, an error is returned.
\end{example}

If we want to prove that given a positive input, the program never returns "Error", we need to be able to talk about inputs directly in predicates.
Currently our symbolic execution does not support this feature, but we would like to add it in the future.
