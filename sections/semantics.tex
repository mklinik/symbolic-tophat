% !TEX root=../main.tex


\section{Semantics}
\label{sec:semantics}



\subsection{Observations}

\todo{Extend for read-only editors.}

\begin{center}
  \usemacro{O-Value}
\end{center}

\begin{center}
  \usemacro{O-Failing}
\end{center}

% \usemacro{O-Inputs}

\fixme{Are these still correct?}



\subsection{Evaluation}

\todo{Add rules for $\Fst$ and $\Snd$.}

\begin{gather*}
  \boxed{\RelationE} \Break
  \userule{Sym-E-Value}\Quad
  \userule{Sym-E-Pair} \Break
  \userule{Sym-E-App} \Break
  \userule{Sym-E-IfTrue} \Break
  \userule{Sym-E-IfFalse} \Break
  \userule{Sym-E-Ref} \Quad
  \userule{Sym-E-Deref} \Break
  \userule{Sym-E-Assign} \Break
  \userule{Sym-E-Edit} \Quad
  \userule{Sym-E-Enter}\Quad
  \userule{Sym-E-Update}\Break
  \userule{Sym-E-Then}\Quad
  \userule{Sym-E-Next}\Break
  \userule{Sym-E-And}\Break
  \userule{Sym-E-Or} \Break
  \userule{Sym-E-Xor}\Quad
  \userule{Sym-E-Fail}
\end{gather*}



\subsection{Normalisation}

\begin{gather*}
  \boxed{\RelationS} \Break
  \userule{Sym-S-ThenStay} \Break
  \userule{Sym-S-ThenFail} \Break
  \userule{Sym-S-ThenCont} \Break
  \userule{Sym-S-OrLeft} \Break
  \userule{Sym-S-OrRight} \Break
  \userule{Sym-S-OrNone} \Break
  \userule{Sym-S-Edit} \Quad
  \userule{Sym-S-Fill} \Break
  \userule{Sym-S-Update} \Quad
  \userule{Sym-S-Fail} \Break
  \userule{Sym-S-Xor} \Quad
  \userule{Sym-S-Next} \Break
  \userule{Sym-S-And}
\end{gather*}


\begin{gather*}
  \boxed{\RelationN} \Break
  \userule{Sym-N-Done} \Break
  \userule{Sym-N-Repeat}
\end{gather*}



\subsection{Handling}

\begin{gather*}
  \boxed{\RelationH} \Break
  \userule{Sym-H-Change} \Quad
  \userule{Sym-H-Fill} \Break
  \userule{Sym-H-Update}\Break
  \userule{Sym-H-Next} \Break
  \userule{Sym-H-PassThen} \Quad
  \userule{Sym-H-PassNext} \Break
  \userule{Sym-H-PickLeft} \Quad
  \userule{Sym-H-PickRight}\Break
  \userule{Sym-H-FirstAnd} \Quad
  \userule{Sym-H-SecondAnd} \Break
  \userule{Sym-H-FirstOr} \Quad
  \userule{Sym-H-SecondOr}
\end{gather*}

Note that \refrule{Sym-H-Empty} is omitted as it does nothing useful for symbolic execution.


\begin{gather*}
  \boxed{\RelationI} \Break
  \userule{Sym-I-Handle}
\end{gather*}


\subsection{Driving}

This section describes the top level symbolic execution function.

It uses the function drive, which takes $t,I,\sigma,\phi$, and is recursively called to produce a list of end states an predicates.
The drive function makes use of triple arrow, a small step semantics that generates all possible steps that can be taken.
Drive then filters this based on the following:

\begin{function}
  \signature{\mathit{drive} :: \Task \times [\mathrm{Inputs}] \times \mathrm{State} \times \mathrm{Predicate} \rightarrow [(\Task,[\mathrm{Inputs}],\mathrm{State},\mathrm{Predicate})]} \\
  \mathit{drive}\ t\ I\ \sigma \ \phi  = \mathit{map} \ (\mathit{concat . drive'}) (\Rrightarrow\ t\ I\ \sigma \ \phi)\\
                                  \mathit{where}\ \mathit{drive'}\ t'\ I\ \sigma'\ \phi'=\\
                                  \begin{array}{ll}
                                    [\ ] & \neg \text{SAT } \phi'\\
                                    \relax [(t',I',\sigma',\phi')] & \Value(t',\sigma') \equiv v \wedge \text{SAT } \phi'\\
                                    \relax [\ ]            & t' \equiv t \wedge \phi' \equiv \phi \wedge \Value(t',\sigma') \equiv \bot\\
                                    \mathit{drive}\ t'\ I'\ \sigma'\ \phi' & (t' \neq t \vee \phi' \neq \phi) \wedge \Value(t',\sigma') \equiv \bot
                                  \end{array}
\end{function}


Where $\text{SAT }\phi$ means that there exists a list of constants $[c_0,\cdots,c_n]$ such that $\phi[s_0\mapsto c_0,\cdots,s_n\mapsto c_n]\equiv\True$.


In order to show that this actually holds, we need to prove some properties, see next section.
