% !TEX root=../main.tex


\section{Language}
\label{sec:language}

The language presented in this section is nearly identical to the original \TOPHAT language presented by \citet{Steenvoorden2019}.
The main difference with the grammar listed here, is the accommodation of symbols.
Symbols can be considered placeholder variables for expected input.
Symbols are treated as values, they have a type, and operations can be performed on them.
Therefore we make these operations explicit in this version,
where in the original they were left implicit.
The following subsections describe in detail how all elements of the \TOPHAT language deal with the accommodation of symbols.


\subsection{Expressions, values, and types}
\label{expressions}

The syntax of \TOPHAT is listed in Figure~\ref{fig:syntaxtophat}

\begin{figure}[h]
  \small
  \usemacro{G-Language-Compact}
  \usemacro{G-Pretasks-Compact}
  \caption{Syntax of \TOPHAT expressions.}
  \label{fig:syntaxtophat}
\end{figure}

Two main changes have been made with regards to the original \TOPHAT semantics.
The differences with the original syntax are highlighted in grey boxes.
First, symbols $s$ have been added to the syntax of expressions.
However, they are not intended to be used by programmers, just like locations $l$.
Instead, they are generated by the semantics as placeholders for inputs.
Second, unary and binary operations have been made explicit.

As mentioned before, symbols are considered to be values.
They have therefore been added to the list of values.
As a result, we must now also regard unary and binary operations as values.
This is due to the fact that the symbols are placeholders for actual values.

\begin{figure}[h]
  \small
  \usemacro{G-Values-Compact}
  \usemacro{G-Tasks-Compact}
  \caption{Syntax of values in \TOPHAT}
  \label{fig:syntaxvalues}
\end{figure}

The types of \TOPHAT remain the same.
However, we do need an additional typing rule, \refrule{T-Sym}, to type symbols,
since they are now part of our expression syntax.
The type of symbols is kept track of in the environment $\Gamma$.

\begin{figure}[h]
  \small
  \usemacro{G-Types-Compact}
  \caption{Syntax of \TOPHAT types}
  \label{fig:syntaxtypes}
\end{figure}

\begin{figure}[h]
  \small
  \highlight{\userule{T-Sym}}
  \caption{Additional typing rule for symbols}
  \label{fig:typingsymbol}
\end{figure}


\subsection{Inputs}

In symbolic execution, we do not know what the input of a program will be.
In the case of \TOPHAT, this means that we do not know the user input, but have to put in placeholder symbols.
This is reflected in the definition of symbolic inputs in \cref{fig:syntaxinputs}

\begin{figure}[h]
  \small
  \usemacro{G-Inputs-Compact}
  \caption{Syntax of symbolic inputs}
  \label{fig:syntaxinputs}
\end{figure}

Inputs are still the same and consist of a potential path, which are tagged with one or more $\First$ and $\Second$.
Actions do not contain concrete values any more, but only symbols $s$.
This symbol is a placeholder for all concrete inputs.
This means that editors can no longer be set to a value $v$, but will instead hold a symbol $s$ after user input.


\subsection{Path conditions}

When the execution of a \TOPHAT program takes a certain path, there are always certain conditions to arrive at that point.
A user selects the left task, a user enters a value, that is used to select the next task, etc.
Since this information is not available during symbolic execution, we need to record how the path depends on the input.
This is done by means of path conditions.
\Cref{fig:syntaxpredicates} lists the syntax for path conditions.

\begin{figure}[h]
  \small
  \usemacro{G-Predicates-Compact}
  \caption{Syntax of path conditions}
  \label{fig:syntaxpredicates}
\end{figure}

Path conditions are a subset of those values that are of a basic type $\beta$.
They can contain symbols, constants, pairs, lists, and operations on them.
